# 记一次MD5妙用
最近项目组中在做历史记录的改造工作，主持讨论了多次，但每次讨论完都觉的很完美了，但实际在写这部分逻辑的时候还是会发现一些问题出来，很难受，反反复复的暴露智商是硬伤，人艰不拆，暂先不扯这些真相了。介绍下实际操作场景，我们的项目是分设计端和运行端的，就是设计端设计的内容保存在数据文件中，运行端去解析该文件，展示设计的内容，其中历史记录部分就是其中一项功能，该功能包括采集外部设备的数据，以及使用表格和曲线来展示数据。但这里有一个要求就是，同一个工程的历史数据文件不能每次下载就新建这个历史数据文件，必须要判断有无更改了历史记录配置，如果有更改则可以重建，否则就不能新建去存储，第一次讨论时就已经考虑到这一点了，确定了是由运行端去比较是否有更改。运行端人员写了一下，发现这个比较很麻烦，因为运行端是在一个嵌入式设备上运行的，内存，硬盘这些都很小，cpu处理也很慢，不仅麻烦，而且运行处理速度也很慢，提出由设计端人员给个标志位，这就是第二次讨论的时候提到的，设计端给出的方案是每次有编辑历史记录部分就置位某个值，下载后，就复位该值。这对于设计端来说也简单，就定了。后面又发现，咱这个设计的数据文件是可以下载到多台设备上的，每次下载完就复位的话，下载到另一台的时候不就没有这个标志位了嘛，这不行啊，同一工程导致两种运行端解析方式，这是不可接受的。然后进行了第三次讨论，有提到说使用历史记录修改版本来区分开来，这是一个感觉还不错的方式。下载到设备上后，设备用当前的那个工程的历史记录版本号与最新的下载的工程中的历史记录版本号进行比对，如果不一样就可以新建，否则不新建，可接着进行记录。这个方式是解决了之前那个问题，但又发现新的问题来，就是设计端更改了历史记录配置后保存，然后又更改历史记录配置，使之和原来的设置是一样的，这时候版本是有更新的，但实际配置没有变化，如果这种情况下载进去，历史数据又新建，显然是不合适的。忽然灵光一闪，这个场景熟悉，判断前后设置是否有修改，可以使用md5计算一下配置信息存在某个地方，下载到设备上后，设备对这个md5值和原来配置的那个记录进行比较，如果相同，则无需新建，否则新建，这个处理方式就避免了更改了配置，又将配置还原为原来配置的问题，这里利用了md5一对一的特点，巧妙的解决了这个问题。但愿这次的讨论能够周全了。2018-09-27 18:21:00  
最后附上C#中对MD5的计算方法
```C#
public static string GetMD5String(string str)
{
    MD5 md5 = MD5.Create();
    byte[] data = Encoding.UTF8.GetBytes(str);
    byte[] data2 = md5.ComputeHash(data);
    return GetByteToString(data2);
}
public static string GetByteToString(byte[] data)
{
    StringBuilder sb = new StringBuilder();
    for(int i = 0; i < data.Length; i++)
    {
        sb.Append(data[i].ToString("x2"));
    }
    return sb.ToString();
}
```